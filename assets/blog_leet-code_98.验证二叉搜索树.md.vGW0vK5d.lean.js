import{_ as i,o as a,c as n,a6 as l}from"./chunks/framework.BkI9ovSD.js";const p="/assets/tree1-1709277867186-1.BiMHmf_f.jpg",e="/assets/tree2-1709437495637-33.CwjHFTkf.jpg",c=JSON.parse('{"title":"98.验证二叉搜索树","description":"","frontmatter":{"title":"98.验证二叉搜索树","date":"2024-03-02T00:00:00.000Z","tags":["树","深度优先搜索","二叉搜索树","二叉树"],"categories":["力扣每日一题"]},"headers":[],"relativePath":"blog/leet-code/98.验证二叉搜索树.md","filePath":"blog/leet-code/98.验证二叉搜索树.md","lastUpdated":1746603753000}'),t={name:"blog/leet-code/98.验证二叉搜索树.md"};function h(k,s,r,d,o,E){return a(),n("div",{"data-pagefind-body":!0},s[0]||(s[0]=[l('<h1 id="_98-验证二叉搜索树" tabindex="-1">98.验证二叉搜索树 <a class="header-anchor" href="#_98-验证二叉搜索树" aria-label="Permalink to &quot;98.验证二叉搜索树&quot;">​</a></h1><p><strong>难度：中等</strong></p><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><img src="'+p+`" alt="img"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：root = [2,1,3]</span></span>
<span class="line"><span>输出：true</span></span></code></pre></div><p><strong>示例 2：</strong></p><p><img src="`+e+`" alt="img"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：root = [5,1,4,null,null,3,6]</span></span>
<span class="line"><span>输出：false</span></span>
<span class="line"><span>解释：根节点的值是 5 ，但是右子节点的值是 4 。</span></span></code></pre></div><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 10^4]</code> 内</li><li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li></ul><h2 id="递归法" tabindex="-1">递归法 <a class="header-anchor" href="#递归法" aria-label="Permalink to &quot;递归法&quot;">​</a></h2><p>二叉搜索树是一个有序树：</p><ul><li>若它的左子树不空，则左子树上所有结点的值都小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值都大于它的根结点的值；</li><li>它的左、右子树也分别为二叉搜索树</li></ul><p>这启示我们设计一个递归函数 <code>isValid(root, lower, upper)</code> 来递归判断，函数表示考虑以 <code>root</code> 为根的子树，判断子树中所有节点的值是否都在 <code>(l,r)</code>的范围内（注意是开区间）。如果 <code>root</code> 节点的值 <code>val</code> 不在 <code>(l,r)</code> 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。</p><p>那么根据二叉搜索树的性质，在递归调用左子树时，我们需要把上界 <code>upper</code> 改为 <code>root.val</code>，即调用 <code>isValid(root.left, lower, root.val)</code>，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 <code>lower</code> 改为 <code>root.val</code>，即调用 <code>isValid(root.right, root.val, upper)</code>。</p><p>函数递归调用的入口为 <code>isValid(root, -inf, +inf)</code>， <code>inf</code> 表示一个无穷大的值。</p><p>算法步骤：</p><ol><li><strong>递归的基本情况</strong>：如果当前节点是<code>null</code>，根据二叉搜索树的定义，空树是有效的二叉搜索树，因此返回<code>true</code>。</li><li><strong>检查当前节点的值</strong>：如果当前节点的值不满足二叉搜索树的性质（即，不在其允许的值范围<code>lower</code>和<code>upper</code>之间），则返回<code>false</code>。具体来说，当前节点的值必须大于其允许的最小值 <code>lower</code> 并且小于其允许的最大值 <code>upper</code>。</li><li><strong>递归检查左右子树</strong>： <ul><li>对于左子树，其允许的值范围是 <code>lower</code> 到当前节点的值。递归调用 <code>isValid</code> 函数，将当前节点的值作为左子树允许的最大值。</li><li>对于右子树，其允许的值范围是当前节点的值到 <code>upper</code>。递归调用 <code>isValid</code> 函数，将当前节点的值作为右子树允许的最小值。</li></ul></li><li><strong>返回结果</strong>：如果当前节点及其所有子树都满足二叉搜索树的性质，则返回 <code>true</code>。</li></ol><h2 id="代码展示" tabindex="-1">代码展示 <a class="header-anchor" href="#代码展示" aria-label="Permalink to &quot;代码展示&quot;">​</a></h2><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isValidBST</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(TreeNode root) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isValid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root, Long.MIN_VALUE, Long.MAX_VALUE);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isValid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(TreeNode root, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lower, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> upper) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (root </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (root.val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lower </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root.val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> upper) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isValid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.left, lower, root.val) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isValid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.right, root.val, upper);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>时间复杂度：O(n)，其中n是树中的节点数。算法需要访问树中的每个节点一次。</p><p>空间复杂度：O(h)，其中h是树的高度。递归调用栈的深度由树的高度决定。在最坏的情况下（树完全倾斜），空间复杂度可以达到O(n)。</p><p><strong>为什么使用 <code>long</code> 类型</strong>：</p><p>使用 <code>long</code> 类型的 <code>Long.MIN_VALUE</code> 和 <code>Long.MAX_VALUE</code> 作为初始的上下界是为了包含 <code>int</code> 类型的所有可能值，因为二叉树节点的值是 <code>int</code> 类型的。这确保了在递归的最开始阶段，根节点的值不会因为边界问题而被错误地判断。</p><h2 id="中序遍历-递归法" tabindex="-1">中序遍历+递归法 <a class="header-anchor" href="#中序遍历-递归法" aria-label="Permalink to &quot;中序遍历+递归法&quot;">​</a></h2><p>核心原理：<strong>二叉搜索树是一个有序树，在中序遍历下其输出的是一个递增序列。</strong></p><p>这启示我们可以在中序遍历的时候，实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果一直大于，说明这个序列是升序的，整棵树是二叉搜索树，否则就不是。</p><p>算法步骤：</p><ol><li><code>prev</code> 变量用于记录中序遍历过程中访问的前一个节点。它在类的成员位置被初始化为<code>null</code>，以便在开始遍历时没有前一个节点。</li><li><code>inorder</code> 方法实现了中序遍历。它首先递归地访问左子树，然后检查当前节点是否满足BST的条件（即当前节点的值应该大于<code>prev</code>节点的值），最后递归地访问右子树。</li><li>如果在任何时候发现序列不是升序的，方法返回<code>false</code>。如果整个遍历过程中没有违反BST的条件，最终返回<code>true</code>。</li></ol><h2 id="代码展示-1" tabindex="-1">代码展示 <a class="header-anchor" href="#代码展示-1" aria-label="Permalink to &quot;代码展示&quot;">​</a></h2><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TreeNode prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用于记录中序遍历过程中的前一个节点</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isValidBST</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(TreeNode root) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 递归进行中序遍历，并检查序列是否升序</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inorder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inorder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(TreeNode node) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 空节点不违反BST的规则</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 首先递归检查左子树</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">inorder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node.left)) {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果左子树不是BST，则直接返回false</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 检查当前节点的值是否大于前一个中序遍历到的节点的值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node.val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev.val) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果不是升序，说明不是BST</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 更新prev为当前节点</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 然后递归检查右子树</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inorder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node.right);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>时间复杂度：O(n)，其中n是树中的节点数。算法需要访问树中的每个节点恰好一次。</p><p>空间复杂度：O(h)，其中h是树的高度，对应递归调用栈的深度。在最坏的情况下（树完全倾斜），空间复杂度可以达到O(n)。</p><h2 id="中序遍历-迭代法" tabindex="-1">中序遍历+迭代法 <a class="header-anchor" href="#中序遍历-迭代法" aria-label="Permalink to &quot;中序遍历+迭代法&quot;">​</a></h2><p>上诉中的递归函数我们也可以用迭代的方式来实现，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其他都相同，具体的代码思路如下：</p><ol><li><strong>初始化</strong>：创建一个栈来保存遍历过程中的节点，以及一个 <code>prev</code> 变量来记录上一次访问的节点。初始时，<code>prev</code> 设置为 <code>null</code>。</li><li><strong>迭代遍历</strong>：使用 <code>current</code> 指针指向当前节点，初始时指向根节点 <code>root</code>。然后进入一个循环，直到 <code>current</code> 为 <code>null</code> 且栈为空。</li><li><strong>向左遍历</strong>：在循环中，首先尽可能地向左遍历，并将沿途的节点压入栈中。这一步确保了能够按照中序遍历的顺序访问每个节点。</li><li><strong>处理节点</strong>：当不能再向左遍历时，从栈中弹出一个节点进行处理。这个节点是当前中序遍历序列中的下一个节点。此时检查这个节点的值是否大于 <code>prev</code> 节点的值。如果不是（即当前节点的值小于等于 <code>prev</code> 节点的值），说明这不是一个有效的BST，返回 <code>false</code>。</li><li><strong>转向右子树</strong>：处理完当前节点后，转向右子树并继续迭代过程。</li><li><strong>完成遍历</strong>：当所有节点都被正确处理且没有发现违反BST性质的情况时，遍历结束，返回 <code>true</code>。</li></ol><p>通过这种方法，算法首先访问最左侧的节点（最深的左子树），然后回到其父节点（根节点），最后处理右子树。这正好符合中序遍历的顺序（左-根-右）。使用栈来存储未来将要访问的节点，从而实现了迭代遍历，而不是使用递归。</p><h2 id="代码展示-2" tabindex="-1">代码展示 <a class="header-anchor" href="#代码展示-2" aria-label="Permalink to &quot;代码展示&quot;">​</a></h2><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isValidBST</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(TreeNode root) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    TreeNode prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用于记录中序遍历过程中的前一个节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Deque&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TreeNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; stack </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LinkedList&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    TreeNode current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 尽可能地向左遍历，并将沿途的节点压入栈</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            stack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current.left;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 当到达最左侧节点后，弹出并处理节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current.val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prev.val) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        prev </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 转向右子树</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current.right;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。</p><p>空间复杂度：O(h)，其中h是树的高度。在最坏的情况下，栈中可能需要存储与树的高度相当数量的节点。对于一棵平衡二叉树，空间复杂度是O(log n)，而对于非平衡二叉树，最坏情况下的空间复杂度可能达到O(n)。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>二叉搜索树是一个有序树，在中序遍历下其输出的是一个递增序列。</p>`,46)]))}const y=i(t,[["render",h]]);export{c as __pageData,y as default};
