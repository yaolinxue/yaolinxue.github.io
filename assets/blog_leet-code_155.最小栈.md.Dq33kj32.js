import{_ as i,o as a,c as n,a6 as p}from"./chunks/framework.BkI9ovSD.js";const E=JSON.parse('{"title":"155.最小栈","description":"","frontmatter":{"title":"155.最小栈","date":"2024-01-11T00:00:00.000Z","tags":["栈","设计"],"categories":["力扣每日一题"]},"headers":[],"relativePath":"blog/leet-code/155.最小栈.md","filePath":"blog/leet-code/155.最小栈.md","lastUpdated":1746603753000}'),l={name:"blog/leet-code/155.最小栈.md"};function t(e,s,k,h,d,c){return a(),n("div",{"data-pagefind-body":!0},s[0]||(s[0]=[p(`<h1 id="_155-最小栈" tabindex="-1">155.最小栈 <a class="header-anchor" href="#_155-最小栈" aria-label="Permalink to &quot;155.最小栈&quot;">​</a></h1><p><strong>难度：中等</strong></p><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><ul><li><code>MinStack()</code> 初始化堆栈对象。</li><li><code>void push(int val)</code> 将元素 val 推入堆栈。</li><li><code>void pop()</code> 删除堆栈顶部的元素。</li><li><code>int top()</code> 获取堆栈顶部的元素。</li><li><code>int getMin()</code> 获取堆栈中的最小元素。</li></ul><p><strong>示例 1:</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：</span></span>
<span class="line"><span>[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span></span>
<span class="line"><span>[[],[-2],[0],[-3],[],[],[],[]]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>输出：</span></span>
<span class="line"><span>[null,null,null,null,-3,null,0,-2]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>解释：</span></span>
<span class="line"><span>MinStack minStack = new MinStack();</span></span>
<span class="line"><span>minStack.push(-2);</span></span>
<span class="line"><span>minStack.push(0);</span></span>
<span class="line"><span>minStack.push(-3);</span></span>
<span class="line"><span>minStack.getMin();   --&gt; 返回 -3.</span></span>
<span class="line"><span>minStack.pop();</span></span>
<span class="line"><span>minStack.top();      --&gt; 返回 0.</span></span>
<span class="line"><span>minStack.getMin();   --&gt; 返回 -2.</span></span></code></pre></div><p><strong>提示：</strong></p><ul><li><code>-2^31 &lt;= val &lt;= 2^31 - 1</code></li><li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</li><li><code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>最多被调用 <code>3 * 10^4</code> 次</li></ul><h2 id="解题思路" tabindex="-1">解题思路 <a class="header-anchor" href="#解题思路" aria-label="Permalink to &quot;解题思路&quot;">​</a></h2><p>要做出这道题目，首先要理解栈结构 <strong>先进后出</strong> 的性质。</p><p>对于栈来说，如果一个元素 <code>a</code> 在入栈时，栈里有其它的元素 <code>b, c, d</code>，那么无论这个栈在之后经历了什么操作，只要 <code>a</code> 在栈中，<code>b, c, d</code> 就一定在栈中，因为在 <code>a</code> 被弹出之前，<code>b, c, d</code> 不会被弹出。</p><p>因此，在操作过程中的任意一个时刻，只要栈顶的元素是 <code>a</code>，那么我们就可以确定栈里面一定有元素 <code>a, b, c, d</code>。</p><p>那么，我们可以在每个元素 <code>a</code> 入栈后，把当前栈内的最小值 <code>m</code> 存储起来，在这之后无论何时，只要栈顶元素是 <code>a</code>，我们都可以确认当前栈内存储的最小值是 <code>m</code>。</p><p>按照上面的思路，我们只需要设计一个数据结构，使得每个元素 <code>a</code> 与其相对应的最小值 <code>m</code> <strong>时刻保持一一对应</strong>。</p><p>因此我们可以使用一个辅助栈 <code>min_stack</code>，与元素栈 <code>stack</code> 同步插入与删除，同时存储和每个元素相对应的最小值（当前栈中的最小值）。</p><p>算法流程：</p><ul><li><p>push() 方法：</p><p>push 元素进 <code>stack</code> 栈顶前：</p><ol><li>如果该元素小于 <code>min_stack</code> 栈顶值，说明新元素的加入，会使得栈内最小值发生改变，所以该值 push 进 <code>stack</code> 的同时，也要将该值 push 到 <code>min_stack</code> 的栈顶</li><li>如果该元素大于或等于 <code>min_stack</code> 栈顶值，说明新元素的加入，不会使得栈内最小值发生改变，所以该值 push 进 <code>stack</code> 的时候，要将 <code>min_stack</code> 的栈顶元素复制一份再次入栈。</li></ol></li><li><p>pop() 方法： pop 元素出 <code>stack</code> 栈顶时，我们一并 pop 出 <code>min_stack</code> 的栈顶元素。</p></li><li><p>上面两个方法的操作，可以保证 <code>min_stack</code> 栈顶元素始终是当前 <code>stack</code> 中的最小值。</p></li><li><p>getMin() 方法： 检索 <code>min_stack</code> 栈顶元素即可。</p></li></ul><h2 id="我的代码-辅助栈法" tabindex="-1">我的代码（辅助栈法） <a class="header-anchor" href="#我的代码-辅助栈法" aria-label="Permalink to &quot;我的代码（辅助栈法）&quot;">​</a></h2><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MinStack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Deque&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; stack;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 主栈，用于存储所有元素</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Deque&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; minStack;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 辅助栈，用于存储每个元素入栈时的最小值</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MinStack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        stack </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LinkedList&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        minStack </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LinkedList&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 如果辅助栈为空，或新元素小于等于辅助栈顶元素，则将新元素推入辅助栈</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 否则，再次将辅助栈顶元素推入辅助栈</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (minStack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> minStack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">peek</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            minStack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(val);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            minStack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(minStack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">peek</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        stack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(val);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将元素推入主栈</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 同时从两个栈中弹出栈顶元素</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        minStack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        stack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> top</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 返回主栈顶元素</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">peek</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getMin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 返回辅助栈顶元素，即当前栈中的最小值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> minStack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">peek</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>时间复杂度：题目中的所有操作，时间复杂度均为 O(1)</p><p>空间复杂度：O(n)</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>栈的实现通常有两种：</p><ol><li>使用数组模拟栈</li><li>使用系统自带的栈结构</li></ol>`,25)]))}const r=i(l,[["render",t]]);export{E as __pageData,r as default};
