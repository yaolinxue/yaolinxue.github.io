import{_ as i,o as a,c as n,a6 as p}from"./chunks/framework.BkI9ovSD.js";const l="/assets/rev1ex1.BDfg5OS1.jpg",t="/assets/rev1ex2.1S1bUBbv.jpg",o=JSON.parse('{"title":"206.反转链表","description":"","frontmatter":{"title":"206.反转链表","date":"2023-07-28T00:00:00.000Z","tags":["递归","链表"],"categories":["力扣每日一题"]},"headers":[],"relativePath":"blog/leet-code/206.反转链表.md","filePath":"blog/leet-code/206.反转链表.md","lastUpdated":1746603570000}'),h={name:"blog/leet-code/206.反转链表.md"};function e(k,s,r,E,d,g){return a(),n("div",{"data-pagefind-body":!0},s[0]||(s[0]=[p('<h1 id="_206-反转链表" tabindex="-1">206.反转链表 <a class="header-anchor" href="#_206-反转链表" aria-label="Permalink to &quot;206.反转链表&quot;">​</a></h1><p><strong>难度：简单</strong></p><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="'+l+`" alt="img"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：head = [1,2,3,4,5]</span></span>
<span class="line"><span>输出：[5,4,3,2,1]</span></span></code></pre></div><p><strong>示例 2：</strong></p><p><img src="`+t+`" alt="img"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：head = [1,2]</span></span>
<span class="line"><span>输出：[2,1]</span></span></code></pre></div><p><strong>示例 3：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：head = []</span></span>
<span class="line"><span>输出：[]</span></span></code></pre></div><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p>**进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><h2 id="解题思路" tabindex="-1">解题思路 <a class="header-anchor" href="#解题思路" aria-label="Permalink to &quot;解题思路&quot;">​</a></h2><p>数组支持 <strong>随机访问</strong>（Random Access），随机访问这个概念在计算机科学中被定义为：<strong>可以用同等的时间访问到一组数据中的任意一个元素</strong>。</p><p>而链表显然是不满足这个特性的。</p><p>数组反转的常见方法是：第一个元素与最后一个元素互换位置，索引持续往中间逼近，重复这个操作即可。</p><p>那么针对链表的反转操作，关键点在于让每个节点的 next 指向自己的 pre 节点。</p><p><strong>如果再定义一个新的链表，来实现对链表元素的反转，则是对内存空间的浪费。</strong></p><p>我的思路：</p><ol><li>从头节点开始遍历，获取当前节点、pre 节点、next 节点 <ol><li>让当前节点的 next 指向 pre</li><li>当前节点 = next 节点</li></ol></li><li>到达链表尾的时候，退出循环</li></ol><h2 id="我的代码-迭代法" tabindex="-1">我的代码（迭代法） <a class="header-anchor" href="#我的代码-迭代法" aria-label="Permalink to &quot;我的代码（迭代法）&quot;">​</a></h2><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ListNode </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reverseList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ListNode </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ListNode pre </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 前一个节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ListNode cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 当前处理的节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ListNode next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 保存cur的下一个节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur.next; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 保存下一个节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            cur.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将当前节点的next指向前一个节点，实现反转</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            pre </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur;       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 更新前一个节点为当前节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> next;      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 移动到下一个节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 当循环结束时，pre 将指向新的头节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><h2 id="递归法" tabindex="-1">递归法 <a class="header-anchor" href="#递归法" aria-label="Permalink to &quot;递归法&quot;">​</a></h2><p>递归法相对抽象一些，但是其实和迭代法是一样的逻辑，同样是当 cur 为空的时候递归结束，不断将 cur.next 指向 pre 的过程。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ListNode </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reverseList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ListNode </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reverse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, head);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ListNode </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reverse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ListNode </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">pre</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ListNode </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cur</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 递归出口</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 递归部分</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ListNode next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 保存cur的下一个节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            cur.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 反转操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            pre </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reverse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pre, cur);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>时间复杂度: O(n)，要递归处理链表的每个节点</p><p>空间复杂度: O(n)，递归调用了 n 层栈空间</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>如果使用 C，C++ 编程语言的话，不要忘了还要从内存中删除这两个移除的节点。</p><p><strong>当然如果使用 Java ，Python 的话就不用手动管理内存了。</strong></p><p>注意虚拟头节点的引入，可以使代码逻辑更统一。</p>`,35)]))}const y=i(h,[["render",e]]);export{o as __pageData,y as default};
