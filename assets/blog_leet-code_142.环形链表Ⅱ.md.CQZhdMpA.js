import{_ as a,o as i,c as n,a6 as l}from"./chunks/framework.BkI9ovSD.js";const t="/assets/image-20230829135004365.c7UkAfZp.png",g=JSON.parse('{"title":"142.环形链表Ⅱ","description":"","frontmatter":{"title":"142.环形链表Ⅱ","date":"2023-08-26T00:00:00.000Z","tags":["哈希表","链表","双指针"],"categories":["力扣每日一题"]},"headers":[],"relativePath":"blog/leet-code/142.环形链表Ⅱ.md","filePath":"blog/leet-code/142.环形链表Ⅱ.md","lastUpdated":1746603570000}'),p={name:"blog/leet-code/142.环形链表Ⅱ.md"};function e(h,s,k,d,r,o){return i(),n("div",{"data-pagefind-body":!0},s[0]||(s[0]=[l(`<h1 id="_142-环形链表ii" tabindex="-1">142.环形链表Ⅱ <a class="header-anchor" href="#_142-环形链表ii" aria-label="Permalink to &quot;142.环形链表Ⅱ&quot;">​</a></h1><p><strong>难度：中等</strong></p><p>给定一个链表的头节点 <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leet-code.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：head = [3,2,0,-4], pos = 1</span></span>
<span class="line"><span>输出：返回索引为 1 的链表节点</span></span>
<span class="line"><span>解释：链表中有一个环，其尾部连接到第二个节点。</span></span></code></pre></div><p><strong>示例 2：</strong></p><p><img src="https://assets.leet-code-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：head = [1,2], pos = 0</span></span>
<span class="line"><span>输出：返回索引为 0 的链表节点</span></span>
<span class="line"><span>解释：链表中有一个环，其尾部连接到第一个节点。</span></span></code></pre></div><p><strong>示例 3：</strong></p><p><img src="https://assets.leet-code-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：head = [1], pos = -1</span></span>
<span class="line"><span>输出：返回 null</span></span>
<span class="line"><span>解释：链表中没有环。</span></span></code></pre></div><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p>**进阶：**你是否可以使用 <code>O(1)</code> 空间解决此题？</p><h2 id="解题思路" tabindex="-1">解题思路 <a class="header-anchor" href="#解题思路" aria-label="Permalink to &quot;解题思路&quot;">​</a></h2><p>联想 <strong>160. 相交链表</strong> 的哈希做法，显然这个题可以采用的暴力做法是：<strong>哈希集合 HashSet</strong></p><p>我的思路：</p><ol><li>设定一个哈希集合 hashSet 用来存储链表 head 里面的节点</li><li>遍历链表 head，对于遍历到的每个节点，判断该节点是否在哈希集合中，并将链表 head 中的每个节点加入哈希集合中 <ul><li>如果当前节点不在哈希集合中，则继续遍历链表 head</li><li>如果当前节点在哈希集合中，则说明目标节点已经找到，链表存在环，返回该节点</li></ul></li><li>若链表 head 遍历结束仍没有找到目标节点，说明链表无环，返回 null</li></ol><h2 id="我的代码-哈希集合" tabindex="-1">我的代码（哈希集合） <a class="header-anchor" href="#我的代码-哈希集合" aria-label="Permalink to &quot;我的代码（哈希集合）&quot;">​</a></h2><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ListNode </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">detectCycle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ListNode head) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    HashSet&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ListNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; set </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HashSet&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ListNode cur;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //用head初始化hashSet</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">set.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">contains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cur) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur.next) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        set.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cur);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //链表无环</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><h3 id="hashset" tabindex="-1">HashSet <a class="header-anchor" href="#hashset" aria-label="Permalink to &quot;HashSet&quot;">​</a></h3><p>结构特点：</p><ul><li>HashSet 是一个<strong>没有重复元素的集合</strong>。它的底层结构是依靠 HashMap 来实现的。实现方式大致为：通过一个 HashMap 存储元素，元素是存放在 HashMap 的 Key 中，而 Value 统一使用一个 Object 对象。</li><li>HashSet <strong>不保证元素的顺序</strong>，而且 HashSet 允许使用 null 元素。</li><li>HashSet 是 <strong>非同步的</strong>，如果多个线程同时访问一个 HashSet ，而其中至少一个线程修改了该 HashSet ，那么它必须保持外部同步。</li><li>HashSet 按 Hash 算法来存储集合的元素，因此具有很好的存取和查找性能。</li></ul><p>使用和理解中需要注意的细节：</p><ul><li><p>HashSet 中是允许存入null值的，但是在 HashSet 中仅仅能够存入一个null值。</p></li><li><p><strong>HashSet 中存储元素的位置是固定的</strong> HashSet 中存储的元素的是无序的，由于 HashSet 底层是基于 Hash 算法实现的，使用了 hashcode，所以 HashSet 中相应的元素的位置是固定的</p></li><li><p><strong>必须小心操作可变对象</strong>（<code>Mutable Object</code>） 如果一个 HashSet 中的可变元素改变了自身状态使得 <code>Object.equals(Object)=true</code>，那么将导致一些问题。</p></li></ul><h2 id="双指针法" tabindex="-1">双指针法 <a class="header-anchor" href="#双指针法" aria-label="Permalink to &quot;双指针法&quot;">​</a></h2><h3 id="思路解析" tabindex="-1">思路解析 <a class="header-anchor" href="#思路解析" aria-label="Permalink to &quot;思路解析&quot;">​</a></h3><p>这道题可以使用 <strong>快慢指针法</strong>，分别定义 fast 和 slow 指针，同时从链表头结点出发，fast 指针每次移动两个节点，slow 指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，则说明这个链表有环。</p><p>问题是，在 fast 一步走两个节点，slow 一步走一个节点的情况下，如果链表有环，这两个指针一定会在环内相遇吗？会不会巧合般的永远错开呢？</p><p>答案是：<strong>fast 指针会先进入环中，并且 fast 指针和 slow 指针一定会在环中相遇。</strong></p><p>证明过程：</p><ol><li>显然 fast 指针先进入环中，我们假设环中一共有 e 个节点</li><li>当 slow 指针首次进入环中，来到环中第 1 个节点时，假设 fast 指针处在环中第 w + 1 个节点的位置，那么二者此时的正向距离为 w，显然 0 &lt;= w &lt; e</li><li>由于 slow 指针一步走一个节点，fast 指针一步走两个节点，那么二者的正向距离从 w 开始，每走 t 步，其正向距离为：(w + 2 * t - t) % e = (w + t) % e</li><li>显然，当 t 从 0 逐步增加到 e - w 的时候，两个指针的距离刚好为 0，此时二者相遇，并且根据上式可知 0 &lt;= t &lt; e - w &lt; e，也就是说，<strong>此次相遇的时候， slow 指针在环中还未走完一圈</strong></li></ol><p>综上，我们证明了可以通过快慢指针法在链表中找到环。</p><p>那么第二个问题是，<strong>在找到环之后，如何找到环的入口</strong>？</p><p>假设从链表头结点到环入口的节点数为 x， 环入口到 fast 指针与 slow 指针首次相遇节点的距离为 y，从相遇节点再到环入口的距离为 z。 如图所示：</p><img src="`+t+`" alt="image-20230829135004365" style="zoom:67%;"><p>显然， fast 指针与 slow 指针首次相遇时： slow 走了 x + y 步，fast 走了 x + y + n (y + z) 步。</p><p>其中 n 的含义是： fast 指针在环内比 slow 多走了 n 圈才遇到 slow 指针，y + z 为环的长度。</p><p>因为 fast 指针一步走两个节点，slow 指针一步走一个节点， 所以 fast 指针的位移 = 2 * slow 指针的位移，即：(x + y) * 2 = x + y + n (y + z)，化简得 x + y = n (y + z)</p><p><strong>如果我们能求得 x，再令一个指针从链表头指针移动 x 步，就可以找到想找环形的入口。</strong></p><p>所以将 x 单独放在等式左边：x = n (y + z) - y，再从 n ( y + z ) 中提出一个 ( y + z ) 来，整理公式之后为如下公式：x = (n - 1) (y + z) + z</p><p><strong>注意：上式的 n 一定是大于等于 1 的，因为 fast 指针至少要多走一圈才能相遇 slow 指针。</strong></p><p>由于 [(n - 1) (y + z) + z] % (y + z) = z，则 x % (y + z) = z，这就意味着，<strong>倘若从头结点出发一个指针 temp，从相遇节点也出发一个指针 slow，这两个指针每步只走一个节点， 那么当 temp 走了 x 步的时候，temp 到达了环入口，slow 也刚好到达了环入口，此时二者刚好是第一次相遇。</strong></p><h3 id="代码展示" tabindex="-1">代码展示 <a class="header-anchor" href="#代码展示" aria-label="Permalink to &quot;代码展示&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ListNode </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">detectCycle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ListNode head) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ListNode fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ListNode slow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 使用快慢指针检测环</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        slow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slow.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fast.next.next;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 快慢指针相遇，表示链表有环</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (fast </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slow) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 从头节点和相遇点同时开始遍历，再次相遇点即为环的起始点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            ListNode temp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (temp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slow) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                temp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> temp.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                slow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> slow.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> temp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //链表无环</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>时间复杂度：O(n)，快慢指针相遇前，指针走的次数小于链表长度，快慢指针相遇后，两个指针走的次数也小于链表长度，总体为走的次数小于 2 * n</p><p>空间复杂度：O(1)</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>这道题目，不仅考察对链表的操作，而且还需要一些数学运算。</p><p>主要考察两知识点：</p><ul><li>判断链表是否环</li><li>如果有环，如何找到这个环的入口</li></ul>`,56)]))}const c=a(p,[["render",e]]);export{g as __pageData,c as default};
