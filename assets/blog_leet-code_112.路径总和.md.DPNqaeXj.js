import{_ as i,o as a,c as n,a6 as t}from"./chunks/framework.BkI9ovSD.js";const l="/assets/pathsum1.5H5nb8MO.jpg",p="/assets/pathsum2.ByYbF_qu.jpg",c=JSON.parse('{"title":"112.路径总和","description":"","frontmatter":{"title":"112.路径总和","date":"2024-03-01T00:00:00.000Z","tags":["树","深度优先搜索","广度优先搜索","回溯","栈","二叉树"],"categories":["力扣每日一题"]},"headers":[],"relativePath":"blog/leet-code/112.路径总和.md","filePath":"blog/leet-code/112.路径总和.md","lastUpdated":1746603570000}'),h={name:"blog/leet-code/112.路径总和.md"};function e(k,s,r,d,E,o){return a(),n("div",{"data-pagefind-body":!0},s[0]||(s[0]=[t('<h1 id="_112-路径总和" tabindex="-1">112.路径总和 <a class="header-anchor" href="#_112-路径总和" aria-label="Permalink to &quot;112.路径总和&quot;">​</a></h1><p><strong>难度：中等</strong></p><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><p><img src="'+l+`" alt="img"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span></span>
<span class="line"><span>输出：true</span></span>
<span class="line"><span>解释：等于目标和的根节点到叶节点路径如上图所示。</span></span></code></pre></div><p><strong>示例 2：</strong></p><p><img src="`+p+`" alt="img"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：root = [1,2,3], targetSum = 5</span></span>
<span class="line"><span>输出：false</span></span>
<span class="line"><span>解释：树中存在两条根节点到叶子节点的路径：</span></span>
<span class="line"><span>(1 --&gt; 2): 和为 3</span></span>
<span class="line"><span>(1 --&gt; 3): 和为 4</span></span>
<span class="line"><span>不存在 sum = 5 的根节点到叶子节点的路径。</span></span></code></pre></div><p><strong>示例 3：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：root = [], targetSum = 0</span></span>
<span class="line"><span>输出：false</span></span>
<span class="line"><span>解释：由于树是空的，所以不存在根节点到叶子节点的路径。</span></span></code></pre></div><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><h2 id="递归法" tabindex="-1">递归法 <a class="header-anchor" href="#递归法" aria-label="Permalink to &quot;递归法&quot;">​</a></h2><p>观察要求我们完成的函数，我们可以归纳出它的功能：查找是否存在从当前节点 <code>root</code> 到叶子节点的路径，满足其路径和为 <code>sum</code>。</p><p>假定从根节点到当前节点的值之和为 <code>sum_t</code>，我们可以 <strong>将这个大问题转化为一个小问题</strong> ：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 <code>sum - sum_t</code>。</p><p>不难发现这满足递归的性质:</p><ol><li>若当前节点就是叶子节点，那么我们直接判断 <code>sum</code> 是否等于 <code>val</code> 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。</li><li>若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。</li></ol><h2 id="代码展示" tabindex="-1">代码展示 <a class="header-anchor" href="#代码展示" aria-label="Permalink to &quot;代码展示&quot;">​</a></h2><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hasPathSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(TreeNode root,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> targetSum){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.left</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">root.right</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">root.val</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">targetSum){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hasPathSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.left,targetSum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">root.val)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hasPathSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.right,targetSum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">root.val);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span></code></pre></div><p>时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。</p><p>空间复杂度：O(h)，其中 h 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(n) 。平均情况下树的高度与节点数的对数正相关，空间复杂度为 O(log⁡n)。</p><h2 id="前序遍历-栈-回溯法" tabindex="-1">前序遍历+栈+回溯法 <a class="header-anchor" href="#前序遍历-栈-回溯法" aria-label="Permalink to &quot;前序遍历+栈+回溯法&quot;">​</a></h2><p>联想 <strong>257.二叉树的所有路径</strong> 题，我们可以想到使用前序遍历的方式，记录从根节点到当前节点的路径和。</p><p>这样我们使用两个栈：一个用于存储节点（<code>nodeStack</code>），另一个用于存储到当前节点为止的路径和（<code>pathSumStack</code>）</p><p>算法步骤：</p><ol><li><strong>初始条件检查</strong>：如果根节点<code>root</code>为空，则直接返回<code>false</code>，表示没有路径可以满足条件。</li><li><strong>初始化栈</strong>：创建两个栈，<code>nodeStack</code>用于存储遍历过程中的节点，<code>pathSumStack</code>用于存储到当前节点为止的路径和。根节点及其值被推入各自的栈作为初始值。</li><li><strong>迭代遍历</strong>：使用一个循环，当<code>nodeStack</code>不为空时进行迭代。每次迭代中，从栈中弹出一个节点（<code>currentNode</code> ）和对应的路径和（<code>currentPathSum</code>）。 <ol><li><strong>叶子节点检查</strong>：如果当前节点是叶子节点（即没有左右子节点），并且其路径和等于<code>targetSum</code> ，则找到了满足条件的路径，返回<code>true</code>。</li><li><strong>右子节点处理</strong>：如果当前节点有右子节点，将右子节点及其对应的路径和（当前路径和加上右子节点的值）推入各自的栈。这样做是为了保持深度优先的遍历顺序，由于栈是后进先出（LIFO）的数据结构，先处理的节点后弹出。</li><li><strong>左子节点处理</strong>：同理，如果当前节点有左子节点，也将左子节点及其对应的路径和推入栈中。</li></ol></li><li>如果遍历完整棵树都没有找到满足条件的路径，则返回<code>false</code>。</li></ol><p>关键点：</p><ul><li><strong>深度优先搜索（DFS）</strong>：通过栈实现非递归的深度优先搜索，以此来遍历树中的所有可能路径。</li><li><strong>路径和的累计</strong>：对于每个节点，算法都计算了从根节点到该节点的路径和，并使用<code>pathSumStack</code>来跟踪这个值。</li><li><strong>叶子节点的特殊处理</strong>：只有当遍历到叶子节点时，算法才检查路径和是否等于<code>targetSum</code>。</li></ul><h2 id="代码展示-1" tabindex="-1">代码展示 <a class="header-anchor" href="#代码展示-1" aria-label="Permalink to &quot;代码展示&quot;">​</a></h2><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> boolean</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hasPathSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(TreeNode root,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> targetSum){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Deque&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TreeNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; nodeStack</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LinkedList&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Deque&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; pathSumStack</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LinkedList&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        nodeStack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        pathSumStack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.val);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nodeStack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        TreeNode currentNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nodeStack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentPathSum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pathSumStack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 如果是叶子节点，并且找到了目标路径</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(currentNode.left</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">currentNode.right</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">currentPathSum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">targetSum){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 因为栈是后进先出，所以先压入右孩子</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(currentNode.right</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        nodeStack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(currentNode.right);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        pathSumStack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(currentPathSum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">currentNode.right.val);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 后压入左孩子</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(currentNode.left</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        nodeStack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(currentNode.left);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        pathSumStack.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(currentPathSum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">currentNode.left.val);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span></code></pre></div><p>时间复杂度：O(n)，其中n是树中节点的数量。算法访问每个节点恰好一次。</p><p>空间复杂度：O(h)，其中h是树的高度。在最坏的情况下（树完全不平衡），空间复杂度可以退化到O(n)。空间复杂度主要由栈的使用决定，栈的最大深度等于树的高度。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>如果可以将大问题转化为一个小问题，那就可以考虑使用递归方法了。</p>`,36)]))}const y=i(h,[["render",e]]);export{c as __pageData,y as default};
