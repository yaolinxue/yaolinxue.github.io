import{_ as i,o as a,c as n,a6 as t}from"./chunks/framework.BkI9ovSD.js";const p="/assets/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B91.SevxZZgR.png",c=JSON.parse('{"title":"24.两两交换链表中的节点","description":"","frontmatter":{"title":"24.两两交换链表中的节点","date":"2023-07-28T00:00:00.000Z","tags":["递归","链表"],"categories":["力扣每日一题"]},"headers":[],"relativePath":"blog/leet-code/24.两两交换链表中的节点.md","filePath":"blog/leet-code/24.两两交换链表中的节点.md","lastUpdated":1746603753000}'),e={name:"blog/leet-code/24.两两交换链表中的节点.md"};function l(h,s,k,d,r,o){return a(),n("div",{"data-pagefind-body":!0},s[0]||(s[0]=[t(`<h1 id="_24-两两交换链表中的节点" tabindex="-1">24.两两交换链表中的节点 <a class="header-anchor" href="#_24-两两交换链表中的节点" aria-label="Permalink to &quot;24.两两交换链表中的节点&quot;">​</a></h1><p><strong>难度：中等</strong></p><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p><strong>示例 1：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：head = [1,2,3,4]</span></span>
<span class="line"><span>输出：[2,1,4,3]</span></span></code></pre></div><p><strong>示例 2：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：head = []</span></span>
<span class="line"><span>输出：[]</span></span></code></pre></div><p><strong>示例 3：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>输入：head = [1]</span></span>
<span class="line"><span>输出：[1]</span></span></code></pre></div><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="解题思路" tabindex="-1">解题思路 <a class="header-anchor" href="#解题思路" aria-label="Permalink to &quot;解题思路&quot;">​</a></h2><p>我的思路：</p><ol><li>设定虚拟头节点 dummy，方便处理边界情况</li><li>设定指针 pre 指向当前处理对的前一个节点</li><li>进入循环，<code>pre.next != null &amp;&amp; pre.next.next != null</code> 确保至少有两个节点可以交换 <ol><li>设定指针 first 指向第一个需要交换的节点，second 指向第二个需要交换的节点</li><li>first 节点的 next 指针原本指向 second 节点，现在令其指向 second 的下一个节点</li><li>令 second 节点的 next 指针指向 first 节点</li><li>pre 节点的 next 指针原来指向 first 节点，现在令其指向 second 节点</li><li>移动 pre 指针到下一对需要交换的节点前，也就是指向 first 节点</li></ol></li></ol><p><img src="`+p+`" alt="24.两两交换链表中的节点1"></p><h2 id="我的代码" tabindex="-1">我的代码 <a class="header-anchor" href="#我的代码" aria-label="Permalink to &quot;我的代码&quot;">​</a></h2><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ListNode </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">swapPairs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ListNode head) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 设置一个虚拟头结点，方便处理边界情况</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ListNode dummy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ListNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, head);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // pre 指向当前处理对的前一个节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ListNode pre </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dummy;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 循环条件确保至少有两个节点可以交换</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (pre.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre.next.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ListNode first </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre.next;    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第一个需要交换的节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ListNode second </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> first.next; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 第二个需要交换的节点</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 交换操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        first.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> second.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        second.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> first;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        pre.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> second;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 移动 pre 到下一对需要交换的节点前</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        pre </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> firstNode;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 返回新链表的头节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dummy.next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>如果使用 C，C++ 编程语言的话，不要忘了还要从内存中删除这两个移除的节点。</p><p><strong>当然如果使用 Java ，Python 的话就不用手动管理内存了。</strong></p><p>注意虚拟头节点的引入，可以使代码逻辑更统一。</p>`,23)]))}const g=i(e,[["render",l]]);export{c as __pageData,g as default};
